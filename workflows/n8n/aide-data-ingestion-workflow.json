{
  "name": "AIDE - Ingestão de Dados ONS",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 1
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Trigger Horário",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "data-ingestion/trigger",
        "responseMode": "responseNode",
        "options": {
          "cors": {
            "allowedOrigins": "*"
          }
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook Manual Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 500],
      "webhookId": "aide-data-ingestion-manual"
    },
    {
      "parameters": {
        "url": "http://localhost:8501/api/health",
        "options": {
          "timeout": 5000,
          "ignoreSSLIssues": true
        }
      },
      "id": "health-check",
      "name": "Health Check Sistema",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [450, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.status }}",
              "rightValue": "healthy",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "system-status",
      "name": "Sistema Disponível?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://dados.ons.org.br/api/v1/datasets",
        "authentication": "none",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "fetch-datasets-list",
      "name": "Buscar Lista Datasets ONS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT dataset_id, external_id, last_updated, update_frequency, metadata->>'version' as version FROM datasets WHERE source_type = 'ONS' AND NOT deleted_at IS NOT NULL",
        "options": {}
      },
      "id": "get-datasets-db",
      "name": "Consultar Datasets BD",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [850, 400],
      "credentials": {
        "postgres": {
          "id": "{{credentials.postgres}}",
          "name": "AIDE PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Comparar datasets ONS com BD e identificar atualizações\nconst onsDatasets = items[0].json;\nconst dbDatasets = items[1].json;\n\nconst datasetsToUpdate = [];\nconst criticalDatasets = ['carga_energia', 'cmo_pld', 'bandeiras_tarifarias'];\n\nfor (const onsDataset of onsDatasets) {\n  const dbDataset = dbDatasets.find(d => d.external_id === onsDataset.id);\n  \n  if (!dbDataset) {\n    datasetsToUpdate.push({\n      ...onsDataset,\n      action: 'create',\n      priority: criticalDatasets.includes(onsDataset.id) ? 'critical' : 'high',\n      version: onsDataset.version || '1.0'\n    });\n  } else {\n    const lastUpdate = new Date(dbDataset.last_updated);\n    const onsUpdate = new Date(onsDataset.updated_at);\n    \n    if (onsUpdate > lastUpdate || onsDataset.version !== dbDataset.version) {\n      datasetsToUpdate.push({\n        ...onsDataset,\n        action: 'update',\n        priority: criticalDatasets.includes(onsDataset.id) ? 'critical' : 'normal',\n        version: onsDataset.version || dbDataset.version\n      });\n    }\n  }\n}\n\n// Ordenar por prioridade\ndatasetsToUpdate.sort((a, b) => {\n  const priorityOrder = { critical: 0, high: 1, normal: 2 };\n  return priorityOrder[a.priority] - priorityOrder[b.priority];\n});\n\n// Adicionar timestamp de processamento\nreturn datasetsToUpdate.map(dataset => ({\n  json: {\n    ...dataset,\n    processing_start: new Date().toISOString(),\n    batch_id: `batch_${Date.now()}`\n  }\n}));"
      },
      "id": "compare-datasets",
      "name": "Comparar e Priorizar",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "batchSize": 3,
        "options": {}
      },
      "id": "split-batches",
      "name": "Dividir em Lotes",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://dados.ons.org.br/api/v1/datasets/{{$json.id}}/data",
        "authentication": "none",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          },
          "timeout": 30000
        },
        "queryParametersUi": {
          "parameter": [
            {
              "name": "start_date",
              "value": "={{$today.minus(7, 'day').toISO()}}"
            },
            {
              "name": "end_date",
              "value": "={{$today.toISO()}}"
            },
            {
              "name": "format",
              "value": "json"
            }
          ]
        }
      },
      "id": "fetch-dataset-data",
      "name": "Baixar Dados Dataset",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1450, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const rawData = $input.first().json;\nconst datasetInfo = $('split-batches').first().json;\nconst datasetId = datasetInfo.id;\n\n// Validações\nif (!rawData || !rawData.data || !Array.isArray(rawData.data)) {\n  throw new Error(`Dados inválidos para dataset ${datasetId}`);\n}\n\nlet transformedData = [];\nconst processingTime = new Date();\n\nswitch(datasetId) {\n  case 'carga_energia':\n    transformedData = rawData.data.map(row => ({\n      dataset_id: datasetId,\n      period_start: new Date(row.din_instante),\n      period_end: new Date(row.din_instante),\n      year: new Date(row.din_instante).getFullYear(),\n      month: new Date(row.din_instante).getMonth() + 1,\n      day: new Date(row.din_instante).getDate(),\n      hour: new Date(row.din_instante).getHours(),\n      region: row.nom_subsistema,\n      subsystem: row.nom_subsistema,\n      metric_type: 'load',\n      metric_name: 'carga_energia',\n      value: parseFloat(row.val_cargaenergiamwmed),\n      unit: 'MWmed',\n      raw_data: row,\n      processed_data: {\n        id_subsistema: row.id_subsistema,\n        quality_flag: row.quality || 'verified',\n        processing_version: datasetInfo.version\n      }\n    }));\n    break;\n    \n  case 'cmo_pld':\n    transformedData = rawData.data.map(row => ({\n      dataset_id: datasetId,\n      period_start: new Date(row.din_instante),\n      period_end: new Date(row.din_instante),\n      year: new Date(row.din_instante).getFullYear(),\n      month: new Date(row.din_instante).getMonth() + 1,\n      day: new Date(row.din_instante).getDate(),\n      hour: 0,\n      region: row.nom_subsistema,\n      subsystem: row.nom_subsistema,\n      metric_type: 'price',\n      metric_name: 'cmo',\n      value: parseFloat(row.val_cmomediasemanal || row.val_cmo),\n      unit: 'R$/MWh',\n      raw_data: row,\n      processed_data: {\n        patamar: row.patamar || 'medio',\n        tipo: row.tipo_preco || 'cmo',\n        processing_version: datasetInfo.version\n      }\n    }));\n    break;\n    \n  case 'bandeiras_tarifarias':\n    transformedData = rawData.data.map(row => ({\n      dataset_id: datasetId,\n      period_start: new Date(row.DatCompetencia),\n      period_end: new Date(row.DatCompetencia),\n      year: new Date(row.DatCompetencia).getFullYear(),\n      month: new Date(row.DatCompetencia).getMonth() + 1,\n      day: 1,\n      hour: 0,\n      region: 'Brasil',\n      subsystem: 'Nacional',\n      metric_type: 'tariff',\n      metric_name: 'bandeira_tarifaria',\n      value: parseFloat(row.VlrAdicionalBandeira),\n      unit: 'R$/100kWh',\n      raw_data: row,\n      processed_data: {\n        bandeira: row.NomBandeiraAcionada,\n        vigencia: row.DatGeracaoConjuntoDados,\n        processing_version: datasetInfo.version\n      }\n    }));\n    break;\n    \n  default:\n    transformedData = rawData.data.map(row => ({\n      dataset_id: datasetId,\n      period_start: processingTime,\n      period_end: processingTime,\n      year: processingTime.getFullYear(),\n      month: processingTime.getMonth() + 1,\n      day: processingTime.getDate(),\n      hour: processingTime.getHours(),\n      region: 'Unknown',\n      subsystem: 'Unknown',\n      metric_type: 'generic',\n      metric_name: datasetId,\n      value: 0,\n      unit: 'unit',\n      raw_data: row,\n      processed_data: {\n        processing_version: datasetInfo.version\n      }\n    }));\n}\n\n// Adicionar metadados de processamento\nreturn transformedData.map(item => ({\n  json: {\n    ...item,\n    created_at: processingTime.toISOString(),\n    batch_id: datasetInfo.batch_id\n  }\n}));"
      },
      "id": "transform-data",
      "name": "Validar e Transformar",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "data_records",
        "columns": "dataset_id,period_start,period_end,year,month,day,hour,region,subsystem,metric_type,metric_name,value,unit,raw_data,processed_data,created_at",
        "additionalFields": {
          "mode": "list",
          "duplicateColumns": "dataset_id,period_start,region,metric_name"
        }
      },
      "id": "insert-data",
      "name": "Inserir Dados no BD",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1850, 300],
      "credentials": {
        "postgres": {
          "id": "{{credentials.postgres}}",
          "name": "AIDE PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH stats AS (\n  SELECT \n    COUNT(*) as total_records,\n    MIN(period_start) as oldest_data,\n    MAX(period_start) as newest_data\n  FROM data_records \n  WHERE dataset_id = '{{$json.dataset_id}}'\n    AND created_at >= NOW() - INTERVAL '1 hour'\n)\nUPDATE datasets \nSET \n  last_updated = NOW(),\n  row_count = (SELECT total_records FROM stats),\n  metadata = jsonb_set(\n    COALESCE(metadata, '{}'),\n    '{last_ingestion}',\n    json_build_object(\n      'records_added', (SELECT total_records FROM stats),\n      'oldest_data', (SELECT oldest_data FROM stats),\n      'newest_data', (SELECT newest_data FROM stats),\n      'batch_id', '{{$json.batch_id}}',\n      'version', '{{$json.processing_version}}'\n    )::jsonb\n  )\nWHERE external_id = '{{$json.dataset_id}}'\nRETURNING *;",
        "options": {}
      },
      "id": "update-dataset-status",
      "name": "Atualizar Status Dataset",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [2050, 300],
      "credentials": {
        "postgres": {
          "id": "{{credentials.postgres}}",
          "name": "AIDE PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Coletar métricas de ingestão\nconst dataset = $('split-batches').first().json;\nconst insertResult = $('insert-data').first().json;\nconst updateResult = $('update-dataset-status').first().json;\n\nconst processingEnd = new Date();\nconst processingStart = new Date(dataset.processing_start);\nconst processingTime = processingEnd - processingStart;\n\nconst metrics = {\n  workflow_name: 'data_ingestion',\n  dataset_id: dataset.id,\n  dataset_name: dataset.name,\n  batch_id: dataset.batch_id,\n  priority: dataset.priority,\n  action: dataset.action,\n  records_processed: $('transform-data').all().length,\n  processing_time_ms: processingTime,\n  status: 'success',\n  timestamp: processingEnd.toISOString(),\n  metadata: {\n    version: dataset.version,\n    row_count: updateResult.row_count,\n    last_updated: updateResult.last_updated\n  }\n};\n\nreturn {json: metrics};"
      },
      "id": "collect-metrics",
      "name": "Coletar Métricas",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/monitoring/metrics",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{JSON.stringify($json)}}",
        "options": {}
      },
      "id": "send-metrics",
      "name": "Enviar Métricas p/ Monitoring",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2450, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=ingestion:status:{{$json.dataset_id}}",
        "value": "={{JSON.stringify($json)}}",
        "keyType": "automatic",
        "expire": true,
        "ttl": 3600,
        "options": {}
      },
      "id": "cache-status",
      "name": "Cache Status Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2650, 300],
      "credentials": {
        "redis": {
          "id": "{{credentials.redis}}",
          "name": "AIDE Redis"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const error = $execution.error || {};\nconst dataset = $('split-batches').first()?.json || {};\n\nconst errorLog = {\n  workflow: 'data_ingestion',\n  dataset_id: dataset.id || 'unknown',\n  dataset_name: dataset.name || 'unknown',\n  batch_id: dataset.batch_id || 'unknown',\n  timestamp: new Date().toISOString(),\n  error: {\n    message: error.message || 'Unknown error',\n    stack: error.stack,\n    code: error.code,\n    node: error.node\n  },\n  context: {\n    priority: dataset.priority,\n    action: dataset.action\n  }\n};\n\nreturn {json: errorLog};"
      },
      "id": "error-handler",
      "name": "Tratar Erros",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 500],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=error:ingestion:{{$now.toMillis()}}",
        "value": "={{JSON.stringify($json)}}",
        "keyType": "automatic",
        "expire": true,
        "ttl": 86400,
        "options": {}
      },
      "id": "cache-error",
      "name": "Cache Erro Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2050, 500],
      "credentials": {
        "redis": {
          "id": "{{credentials.redis}}",
          "name": "AIDE Redis"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/monitoring/alert",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{JSON.stringify({severity: 'high', type: 'ingestion_error', details: $json})}}",
        "options": {}
      },
      "id": "send-error-alert",
      "name": "Enviar Alerta de Erro",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 500],
      "continueOnFail": true
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "response-webhook",
      "name": "Responder Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2850, 300]
    }
  ],
  "connections": {
    "cron-trigger": {
      "main": [[{"node": "health-check", "type": "main", "index": 0}]]
    },
    "webhook-trigger": {
      "main": [[{"node": "health-check", "type": "main", "index": 0}]]
    },
    "health-check": {
      "main": [[{"node": "system-status", "type": "main", "index": 0}]]
    },
    "system-status": {
      "main": [
        [
          {"node": "fetch-datasets-list", "type": "main", "index": 0},
          {"node": "get-datasets-db", "type": "main", "index": 0}
        ],
        [{"node": "response-webhook", "type": "main", "index": 0}]
      ]
    },
    "fetch-datasets-list": {
      "main": [[{"node": "compare-datasets", "type": "main", "index": 0}]]
    },
    "get-datasets-db": {
      "main": [[{"node": "compare-datasets", "type": "main", "index": 1}]]
    },
    "compare-datasets": {
      "main": [[{"node": "split-batches", "type": "main", "index": 0}]]
    },
    "split-batches": {
      "main": [[{"node": "fetch-dataset-data", "type": "main", "index": 0}]]
    },
    "fetch-dataset-data": {
      "main": [
        [{"node": "transform-data", "type": "main", "index": 0}],
        [{"node": "error-handler", "type": "main", "index": 0}]
      ]
    },
    "transform-data": {
      "main": [[{"node": "insert-data", "type": "main", "index": 0}]]
    },
    "insert-data": {
      "main": [[{"node": "update-dataset-status", "type": "main", "index": 0}]]
    },
    "update-dataset-status": {
      "main": [[{"node": "collect-metrics", "type": "main", "index": 0}]]
    },
    "collect-metrics": {
      "main": [
        [
          {"node": "send-metrics", "type": "main", "index": 0},
          {"node": "cache-status", "type": "main", "index": 0}
        ]
      ]
    },
    "cache-status": {
      "main": [[{"node": "split-batches", "type": "main", "index": 0}]]
    },
    "send-metrics": {
      "main": [[{"node": "response-webhook", "type": "main", "index": 0}]]
    },
    "error-handler": {
      "main": [
        [
          {"node": "cache-error", "type": "main", "index": 0},
          {"node": "send-error-alert", "type": "main", "index": 0}
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "{{errorWorkflowId}}"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 2,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "1.0.0"
}