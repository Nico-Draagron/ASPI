{
  "name": "AIDE - Monitoramento e Alertas",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "cron-monitor",
      "name": "Check a cada 5 min",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "monitoring/metrics",
        "responseMode": "immediateResponse",
        "options": {
          "cors": {
            "allowedOrigins": "*"
          }
        }
      },
      "id": "webhook-metrics",
      "name": "Webhook Receber M√©tricas",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 500],
      "webhookId": "aide-metrics-receiver"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "monitoring/alert",
        "responseMode": "immediateResponse",
        "options": {
          "cors": {
            "allowedOrigins": "*"
          }
        }
      },
      "id": "webhook-alert",
      "name": "Webhook Receber Alertas",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 700],
      "webhookId": "aide-alert-receiver"
    },
    {
      "parameters": {
        "jsCode": "// Definir m√©tricas a monitorar com thresholds din√¢micos\nconst metrics = [\n  {\n    name: 'database_health',\n    query: 'SELECT 1 as health',\n    type: 'postgres',\n    threshold: null,\n    critical: true,\n    description: 'Verificar conex√£o com PostgreSQL'\n  },\n  {\n    name: 'redis_health',\n    command: 'PING',\n    type: 'redis',\n    expected: 'PONG',\n    critical: true,\n    description: 'Verificar conex√£o com Redis'\n  },\n  {\n    name: 'data_freshness',\n    query: `\n      SELECT \n        dataset_id, \n        MAX(period_start) as last_update,\n        EXTRACT(EPOCH FROM (NOW() - MAX(period_start)))/3600 as hours_since_update\n      FROM data_records\n      WHERE dataset_id IN ('carga_energia', 'cmo_pld', 'bandeiras_tarifarias')\n      GROUP BY dataset_id\n    `,\n    type: 'postgres',\n    threshold: 24,\n    critical: false,\n    description: 'Verificar atualiza√ß√£o dos dados cr√≠ticos'\n  },\n  {\n    name: 'error_rate',\n    query: `\n      SELECT \n        COUNT(*) as error_count,\n        COUNT(CASE WHEN created_at > NOW() - INTERVAL '1 hour' THEN 1 END) as recent_errors,\n        COUNT(CASE WHEN severity = 'critical' THEN 1 END) as critical_errors\n      FROM error_logs\n      WHERE created_at > NOW() - INTERVAL '24 hours'\n    `,\n    type: 'postgres',\n    threshold: 100,\n    critical: false,\n    description: 'Taxa de erros do sistema'\n  },\n  {\n    name: 'api_response_time',\n    url: 'http://localhost:8501/api/health',\n    type: 'http',\n    timeout: 5000,\n    threshold: 3000,\n    critical: false,\n    description: 'Tempo de resposta da API'\n  },\n  {\n    name: 'disk_usage',\n    query: `\n      SELECT \n        pg_database_size('aide_db')/1024/1024 as size_mb,\n        pg_database_size('aide_db')/1024/1024/1024 as size_gb,\n        (pg_database_size('aide_db')::float / \n         pg_settings.setting::bigint)::float * 100 as usage_percent\n      FROM pg_settings\n      WHERE name = 'shared_buffers'\n    `,\n    type: 'postgres',\n    threshold: 10000,\n    critical: false,\n    description: 'Uso de disco do banco de dados'\n  },\n  {\n    name: 'active_sessions',\n    command: `EVAL \"return #redis.call('KEYS', 'session:*')\" 0`,\n    type: 'redis',\n    threshold: 1000,\n    critical: false,\n    description: 'Sess√µes ativas no sistema'\n  },\n  {\n    name: 'ingestion_status',\n    query: `\n      SELECT \n        dataset_id,\n        last_updated,\n        CASE \n          WHEN last_updated > NOW() - INTERVAL '1 hour' THEN 'recent'\n          WHEN last_updated > NOW() - INTERVAL '24 hours' THEN 'ok'\n          ELSE 'stale'\n        END as status\n      FROM datasets\n      WHERE source_type = 'ONS'\n        AND deleted_at IS NULL\n    `,\n    type: 'postgres',\n    threshold: null,\n    critical: false,\n    description: 'Status da ingest√£o de dados'\n  },\n  {\n    name: 'chat_usage',\n    query: `\n      SELECT \n        COUNT(*) as total_messages,\n        COUNT(DISTINCT session_id) as unique_sessions,\n        COUNT(DISTINCT user_id) as unique_users,\n        AVG(CASE WHEN role = 'assistant' \n            THEN LENGTH(content) END) as avg_response_length\n      FROM chat_history\n      WHERE created_at > NOW() - INTERVAL '1 hour'\n    `,\n    type: 'postgres',\n    threshold: null,\n    critical: false,\n    description: 'Uso do chat na √∫ltima hora'\n  }\n];\n\nreturn metrics.map(m => ({json: m}));"
      },
      "id": "define-metrics",
      "name": "Definir M√©tricas",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "process-metrics",
      "name": "Processar M√©tricas",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [650, 300]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.type}}",
                    "rightValue": "postgres",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "postgres"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.type}}",
                    "rightValue": "redis",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "redis"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.type}}",
                    "rightValue": "http",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "http"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "check-metric-type",
      "name": "Tipo de M√©trica",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [850, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{$json.query}}",
        "options": {}
      },
      "id": "postgres-check",
      "name": "Check PostgreSQL",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1050, 200],
      "credentials": {
        "postgres": {
          "id": "{{credentials.postgres}}",
          "name": "AIDE PostgreSQL"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeCommand",
        "command": "={{$json.command}}",
        "arguments": {},
        "options": {}
      },
      "id": "redis-check",
      "name": "Check Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1050, 300],
      "credentials": {
        "redis": {
          "id": "{{credentials.redis}}",
          "name": "AIDE Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{$json.url}}",
        "authentication": "none",
        "options": {
          "timeout": "={{$json.timeout}}",
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "id": "http-check",
      "name": "Check HTTP",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const metric = $('process-metrics').first().json;\nconst result = $input.first().json;\nconst checkTime = new Date();\n\nlet status = 'ok';\nlet value = null;\nlet message = '';\nlet details = {};\n\n// Verificar se houve erro\nif (result.error) {\n  status = 'error';\n  message = result.error?.message || 'Check failed';\n  details.error = result.error;\n} else {\n  // Processar resultado por tipo de m√©trica\n  switch(metric.type) {\n    case 'postgres':\n      if (Array.isArray(result) && result.length > 0) {\n        const data = result[0];\n        \n        // Para m√©tricas com threshold\n        if (metric.threshold) {\n          const metricValue = data[Object.keys(data)[0]];\n          value = metricValue;\n          \n          if (typeof metricValue === 'number' && metricValue > metric.threshold) {\n            status = 'warning';\n            message = `Valor ${metricValue} excede threshold ${metric.threshold}`;\n          }\n        }\n        \n        // Para data_freshness\n        if (metric.name === 'data_freshness') {\n          const staleDatasets = result.filter(row => row.hours_since_update > 24);\n          if (staleDatasets.length > 0) {\n            status = 'warning';\n            message = `Datasets desatualizados: ${staleDatasets.map(d => d.dataset_id).join(', ')}`;\n            details.stale_datasets = staleDatasets;\n          }\n        }\n        \n        // Para error_rate\n        if (metric.name === 'error_rate' && data.critical_errors > 0) {\n          status = 'warning';\n          message = `${data.critical_errors} erros cr√≠ticos nas √∫ltimas 24h`;\n          value = data.error_count;\n        }\n        \n        // Para ingestion_status\n        if (metric.name === 'ingestion_status') {\n          const staleDatasets = result.filter(row => row.status === 'stale');\n          if (staleDatasets.length > 0) {\n            status = 'warning';\n            message = `${staleDatasets.length} datasets sem atualiza√ß√£o h√° mais de 24h`;\n            details.datasets = staleDatasets;\n          }\n        }\n        \n        // Para chat_usage\n        if (metric.name === 'chat_usage') {\n          value = data.total_messages;\n          details = data;\n        }\n      }\n      break;\n      \n    case 'redis':\n      if (metric.expected) {\n        if (result !== metric.expected) {\n          status = 'error';\n          message = `Esperado ${metric.expected}, recebido ${result}`;\n        }\n      } else if (metric.threshold) {\n        // Para contagem (como sess√µes ativas)\n        value = typeof result === 'number' ? result : (Array.isArray(result) ? result.length : 0);\n        if (value > metric.threshold) {\n          status = 'warning';\n          message = `Contagem ${value} excede threshold ${metric.threshold}`;\n        }\n      }\n      break;\n      \n    case 'http':\n      const responseTime = result.responseTime || \n        (result.timings ? result.timings.total : 0);\n      const statusCode = result.statusCode || result.status;\n      \n      value = responseTime;\n      details = {\n        statusCode: statusCode,\n        responseTime: responseTime\n      };\n      \n      if (statusCode !== 200 && statusCode !== 201) {\n        status = 'error';\n        message = `HTTP ${statusCode}`;\n      } else if (metric.threshold && responseTime > metric.threshold) {\n        status = 'warning';\n        message = `Resposta lenta: ${responseTime}ms`;\n      }\n      break;\n  }\n}\n\n// Determinar severidade\nconst severity = \n  (metric.critical && status === 'error') ? 'critical' :\n  (status === 'error') ? 'high' :\n  (status === 'warning') ? 'medium' : 'low';\n\n// Adicionar contexto baseado no hist√≥rico (se dispon√≠vel)\nconst previousStatus = $('get-previous-status').first()?.json;\nif (previousStatus) {\n  if (previousStatus.status === 'ok' && status !== 'ok') {\n    details.status_change = 'degraded';\n    details.previous_status = previousStatus.status;\n  } else if (previousStatus.status !== 'ok' && status === 'ok') {\n    details.status_change = 'recovered';\n    details.previous_status = previousStatus.status;\n  }\n}\n\nreturn {json: {\n  metric_name: metric.name,\n  metric_description: metric.description,\n  status: status,\n  value: value,\n  message: message,\n  severity: severity,\n  timestamp: checkTime.toISOString(),\n  details: {\n    type: metric.type,\n    threshold: metric.threshold,\n    critical: metric.critical,\n    raw_result: result,\n    ...details\n  }\n}};"
      },
      "id": "evaluate-result",
      "name": "Avaliar Resultado",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "operation": "get",
        "key": "=metric:status:{{$json.metric_name}}",
        "options": {}
      },
      "id": "get-previous-status",
      "name": "Buscar Status Anterior",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1250, 150],
      "credentials": {
        "redis": {
          "id": "{{credentials.redis}}",
          "name": "AIDE Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "monitoring_metrics",
        "columns": "metric_name,status,value,message,severity,timestamp,details",
        "additionalFields": {},
        "options": {}
      },
      "id": "save-metric",
      "name": "Salvar M√©trica",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1450, 300],
      "credentials": {
        "postgres": {
          "id": "{{credentials.postgres}}",
          "name": "AIDE PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=metric:status:{{$json.metric_name}}",
        "value": "={{JSON.stringify({status: $json.status, value: $json.value, timestamp: $json.timestamp})}}",
        "keyType": "automatic",
        "expire": true,
        "ttl": 900,
        "options": {}
      },
      "id": "cache-metric-status",
      "name": "Cache Status M√©trica",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1650, 300],
      "credentials": {
        "redis": {
          "id": "{{credentials.redis}}",
          "name": "AIDE Redis"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{$json.status}}",
              "rightValue": "ok",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "check-alert-needed",
      "name": "Precisa Alertar?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "options": {
          "reset": false,
          "keepOnlyProperties": [],
          "includeOtherFields": true
        }
      },
      "id": "wait-all-metrics",
      "name": "Aguardar Todas",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [2050, 200]
    },
    {
      "parameters": {
        "jsCode": "const alerts = $input.all().map(item => item.json);\nconst timestamp = new Date();\n\n// Agrupar alertas por severidade\nconst grouped = {\n  critical: [],\n  high: [],\n  medium: [],\n  low: []\n};\n\nalerts.forEach(alert => {\n  if (grouped[alert.severity]) {\n    grouped[alert.severity].push(alert);\n  }\n});\n\n// Construir mensagem de alerta\nlet message = 'üö® **ALERTA - AIDE - Monitoramento**\\n\\n';\nmessage += `üìÖ ${timestamp.toLocaleString('pt-BR')}\\n\\n`;\n\nif (grouped.critical.length > 0) {\n  message += 'üî¥ **CR√çTICO**\\n';\n  grouped.critical.forEach(a => {\n    message += `‚Ä¢ ${a.metric_description || a.metric_name}: ${a.message}\\n`;\n  });\n  message += '\\n';\n}\n\nif (grouped.high.length > 0) {\n  message += 'üü† **ALTO**\\n';\n  grouped.high.forEach(a => {\n    message += `‚Ä¢ ${a.metric_description || a.metric_name}: ${a.message}\\n`;\n  });\n  message += '\\n';\n}\n\nif (grouped.medium.length > 0) {\n  message += 'üü° **M√âDIO**\\n';\n  grouped.medium.forEach(a => {\n    message += `‚Ä¢ ${a.metric_description || a.metric_name}: ${a.message}\\n`;\n  });\n  message += '\\n';\n}\n\n// Adicionar informa√ß√µes sobre mudan√ßas de status\nconst statusChanges = alerts.filter(a => a.details?.status_change);\nif (statusChanges.length > 0) {\n  message += 'üìä **Mudan√ßas de Status**\\n';\n  statusChanges.forEach(a => {\n    const emoji = a.details.status_change === 'recovered' ? '‚úÖ' : '‚ö†Ô∏è';\n    message += `${emoji} ${a.metric_name}: ${a.details.status_change}\\n`;\n  });\n  message += '\\n';\n}\n\n// Determinar canais de notifica√ß√£o\nconst channels = [];\nif (grouped.critical.length > 0) {\n  channels.push('telegram', 'email', 'slack', 'webhook');\n} else if (grouped.high.length > 0) {\n  channels.push('telegram', 'slack');\n} else {\n  channels.push('slack');\n}\n\n// Adicionar recomenda√ß√µes\nconst recommendations = [];\nalerts.forEach(a => {\n  if (a.metric_name === 'data_freshness' && a.status !== 'ok') {\n    recommendations.push('Verificar processo de ingest√£o de dados');\n  }\n  if (a.metric_name === 'disk_usage' && a.value > 8000) {\n    recommendations.push('Considerar limpeza de dados antigos ou expans√£o de armazenamento');\n  }\n  if (a.metric_name === 'error_rate' && a.value > 50) {\n    recommendations.push('Revisar logs de erro para identificar padr√µes de falha');\n  }\n  if (a.metric_name === 'api_response_time' && a.status === 'warning') {\n    recommendations.push('Otimizar queries ou aumentar recursos do servidor');\n  }\n});\n\nif (recommendations.length > 0) {\n  message += 'üí° **Recomenda√ß√µes**\\n';\n  recommendations.forEach(r => {\n    message += `‚Ä¢ ${r}\\n`;\n  });\n}\n\nreturn {json: {\n  message: message,\n  channels: channels,\n  alert_count: alerts.length,\n  critical_count: grouped.critical.length,\n  high_count: grouped.high.length,\n  medium_count: grouped.medium.length,\n  alerts: grouped,\n  recommendations: recommendations,\n  timestamp: timestamp.toISOString()\n}};"
      },
      "id": "prepare-alert",
      "name": "Preparar Alerta",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 200]
    },
    {
      "parameters": {
        "content": "## Canais de Notifica√ß√£o\nCondicional baseado em severidade",
        "height": 80,
        "width": 200
      },
      "id": "note-channels",
      "name": "Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [2430, 50]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{$json.channels}}",
              "rightValue": "telegram",
              "operator": {
                "type": "array",
                "operation": "contains",
                "rightType": "string"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-telegram",
      "name": "Enviar Telegram?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.1,
      "position": [2450, 100],
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{$json.channels}}",
              "rightValue": "slack",
              "operator": {
                "type": "array",
                "operation": "contains",
                "rightType": "string"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-slack",
      "name": "Enviar Slack?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.1,
      "position": [2450, 250]
    },
    {
      "parameters": {
        "jsCode": "// Processar m√©tricas externas recebidas via webhook\nconst input = $input.first().json;\nconst timestamp = new Date();\n\n// Validar entrada\nif (!input.workflow_name || !input.metrics) {\n  throw new Error('workflow_name e metrics s√£o obrigat√≥rios');\n}\n\n// Processar m√©tricas por workflow\nlet processedMetric = {};\n\nswitch(input.workflow_name) {\n  case 'data_ingestion':\n    processedMetric = {\n      metric_name: `ingestion_${input.dataset_id || 'unknown'}`,\n      metric_description: `Ingest√£o de dados: ${input.dataset_name || input.dataset_id}`,\n      status: input.status || 'unknown',\n      value: input.records_processed || 0,\n      message: `${input.action || 'processed'} ${input.records_processed || 0} registros em ${input.processing_time_ms || 0}ms`,\n      severity: input.status === 'error' ? 'high' : 'low',\n      timestamp: timestamp.toISOString(),\n      details: {\n        workflow: 'data_ingestion',\n        batch_id: input.batch_id,\n        priority: input.priority,\n        ...input.metadata\n      }\n    };\n    break;\n    \n  case 'chat_processing':\n    const metrics = input.metrics;\n    processedMetric = {\n      metric_name: 'chat_request',\n      metric_description: 'Processamento de chat',\n      status: 'ok',\n      value: metrics.processing_time_ms || 0,\n      message: `Chat processado em ${metrics.processing_time_ms}ms, ${metrics.tokens_used || 0} tokens`,\n      severity: 'low',\n      timestamp: timestamp.toISOString(),\n      details: {\n        workflow: 'chat_processing',\n        model: metrics.model,\n        tokens: metrics.tokens_used,\n        data_freshness: metrics.data_freshness,\n        function_called: metrics.function_called\n      }\n    };\n    break;\n    \n  default:\n    processedMetric = {\n      metric_name: input.metric_name || 'external_metric',\n      metric_description: input.description || 'M√©trica externa',\n      status: input.status || 'unknown',\n      value: input.value || 0,\n      message: input.message || 'M√©trica recebida',\n      severity: input.severity || 'low',\n      timestamp: timestamp.toISOString(),\n      details: input\n    };\n}\n\nreturn {json: processedMetric};"
      },
      "id": "process-external-metric",
      "name": "Processar M√©trica Externa",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 500]
    },
    {
      "parameters": {
        "jsCode": "// Gerar relat√≥rio consolidado de sa√∫de do sistema\nconst allMetrics = $('save-metric').all().map(item => item.json);\nconst timestamp = new Date();\n\n// Calcular estat√≠sticas\nconst stats = {\n  total_checks: allMetrics.length,\n  healthy: allMetrics.filter(m => m.status === 'ok').length,\n  warnings: allMetrics.filter(m => m.status === 'warning').length,\n  errors: allMetrics.filter(m => m.status === 'error').length,\n  critical: allMetrics.filter(m => m.severity === 'critical').length\n};\n\n// Calcular health score (0-100)\nlet healthScore = 100;\nstats.errors > 0 && (healthScore -= stats.errors * 10);\nstats.warnings > 0 && (healthScore -= stats.warnings * 5);\nstats.critical > 0 && (healthScore -= stats.critical * 20);\nhealthScore = Math.max(0, healthScore);\n\n// Determinar status geral\nlet overallStatus = 'healthy';\nif (healthScore < 50 || stats.critical > 0) {\n  overallStatus = 'critical';\n} else if (healthScore < 75 || stats.errors > 0) {\n  overallStatus = 'degraded';\n} else if (healthScore < 90 || stats.warnings > 0) {\n  overallStatus = 'warning';\n}\n\n// Agrupar m√©tricas por categoria\nconst categorizedMetrics = {\n  infrastructure: [],\n  data: [],\n  application: [],\n  usage: []\n};\n\nallMetrics.forEach(m => {\n  const category = \n    ['database_health', 'redis_health', 'disk_usage'].includes(m.metric_name) ? 'infrastructure' :\n    ['data_freshness', 'ingestion_status'].includes(m.metric_name) ? 'data' :\n    ['api_response_time', 'error_rate', 'active_sessions'].includes(m.metric_name) ? 'application' :\n    'usage';\n    \n  categorizedMetrics[category].push({\n    name: m.metric_name,\n    status: m.status,\n    value: m.value,\n    message: m.message\n  });\n});\n\n// Gerar recomenda√ß√µes baseadas no estado atual\nconst recommendations = [];\n\nif (stats.critical > 0) {\n  recommendations.push({\n    priority: 'high',\n    action: 'Investigar imediatamente os alertas cr√≠ticos'\n  });\n}\n\nallMetrics.forEach(m => {\n  if (m.metric_name === 'data_freshness' && m.status !== 'ok') {\n    recommendations.push({\n      priority: 'medium',\n      action: 'Verificar processo de ingest√£o de dados',\n      details: m.details?.stale_datasets\n    });\n  }\n  \n  if (m.metric_name === 'disk_usage' && m.value > 8000) {\n    recommendations.push({\n      priority: 'medium',\n      action: 'Planejar limpeza de dados ou expans√£o de armazenamento',\n      details: `Uso atual: ${m.value}MB`\n    });\n  }\n  \n  if (m.metric_name === 'error_rate' && m.value > 50) {\n    recommendations.push({\n      priority: 'high',\n      action: 'Analisar logs de erro para identificar causa raiz',\n      details: m.details\n    });\n  }\n});\n\n// Criar relat√≥rio completo\nconst report = {\n  timestamp: timestamp.toISOString(),\n  health_score: healthScore,\n  status: overallStatus,\n  statistics: stats,\n  categories: categorizedMetrics,\n  metrics_summary: allMetrics.map(m => ({\n    name: m.metric_name,\n    status: m.status,\n    value: m.value,\n    severity: m.severity,\n    message: m.message\n  })),\n  recommendations: recommendations,\n  metadata: {\n    check_interval: '5 minutes',\n    last_check: timestamp.toISOString(),\n    version: '1.0.0'\n  }\n};\n\nreturn {json: report};"
      },
      "id": "generate-report",
      "name": "Gerar Relat√≥rio",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2850, 400]
    },
    {
      "parameters": {
        "operation": "set",
        "key": "health:latest",
        "value": "={{JSON.stringify($json)}}",
        "keyType": "automatic",
        "expire": true,
        "ttl": 600,
        "options": {}
      },
      "id": "cache-health",
      "name": "Cache Health Report",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [3050, 400],
      "credentials": {
        "redis": {
          "id": "{{credentials.redis}}",
          "name": "AIDE Redis"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:8501/api/health-report",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{JSON.stringify($json)}}",
        "options": {}
      },
      "id": "send-report-api",
      "name": "Enviar Report p/ API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3250, 400],
      "continueOnFail": true
    }
  ],
  "connections": {
    "cron-monitor": {
      "main": [[{"node": "define-metrics", "type": "main", "index": 0}]]
    },
    "webhook-metrics": {
      "main": [[{"node": "process-external-metric", "type": "main", "index": 0}]]
    },
    "webhook-alert": {
      "main": [[{"node": "prepare-alert", "type": "main", "index": 0}]]
    },
    "define-metrics": {
      "main": [[{"node": "process-metrics", "type": "main", "index": 0}]]
    },
    "process-metrics": {
      "main": [[{"node": "check-metric-type", "type": "main", "index": 0}]]
    },
    "check-metric-type": {
      "main": [
        [{"node": "postgres-check", "type": "main", "index": 0}],
        [{"node": "redis-check", "type": "main", "index": 0}],
        [{"node": "http-check", "type": "main", "index": 0}]
      ]
    },
    "postgres-check": {
      "main": [
        [
          {"node": "get-previous-status", "type": "main", "index": 0},
          {"node": "evaluate-result", "type": "main", "index": 0}
        ]
      ]
    },
    "redis-check": {
      "main": [
        [
          {"node": "get-previous-status", "type": "main", "index": 0},
          {"node": "evaluate-result", "type": "main", "index": 0}
        ]
      ]
    },
    "http-check": {
      "main": [
        [
          {"node": "get-previous-status", "type": "main", "index": 0},
          {"node": "evaluate-result", "type": "main", "index": 0}
        ]
      ]
    },
    "evaluate-result": {
      "main": [[{"node": "save-metric", "type": "main", "index": 0}]]
    },
    "save-metric": {
      "main": [
        [
          {"node": "cache-metric-status", "type": "main", "index": 0},
          {"node": "check-alert-needed", "type": "main", "index": 0}
        ]
      ]
    },
    "cache-metric-status": {
      "main": [[{"node": "process-metrics", "type": "main", "index": 0}]]
    },
    "check-alert-needed": {
      "main": [
        [{"node": "wait-all-metrics", "type": "main", "index": 0}],
        [{"node": "process-metrics", "type": "main", "index": 0}]
      ]
    },
    "wait-all-metrics": {
      "main": [[{"node": "prepare-alert", "type": "main", "index": 0}]]
    },
    "prepare-alert": {
      "main": [
        [
          {"node": "check-telegram", "type": "main", "index": 0},
          {"node": "check-slack", "type": "main", "index": 0}
        ]
      ]
    },
    "process-metrics": {
      "main": [[{"node": "generate-report", "type": "main", "index": 0}]]
    },
    "generate-report": {
      "main": [[{"node": "cache-health", "type": "main", "index": 0}]]
    },
    "cache-health": {
      "main": [[{"node": "send-report-api", "type": "main", "index": 0}]]
    },
    "process-external-metric": {
      "main": [[{"node": "save-metric", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 3,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "1.0.0"
}